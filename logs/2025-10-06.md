# Development Log - October 7, 2025

## Session 1: Project Initialization

### Goals
1. Update project plan with configuration file support
2. Create project structure (plans/, archive/, logs/)
3. Break down plan into phase-based files
4. Initialize Go project

### Completed
- ‚úÖ Updated plan.md to include configuration file design principle
- ‚úÖ Updated plan.md with config/ package in project layout
- ‚úÖ Added Phase 0 for project setup in development plan
- ‚úÖ Updated translate command documentation with config-based usage
- ‚úÖ Created project folder structure (plans/, archive/, logs/)
- ‚úÖ Created phase-based planning files:
  - phase-0-setup.md (Project initialization)
  - phase-1-parsing.md (Core parser + listempty)
  - phase-2-searching.md (Search commands)
  - phase-3-translation.md (Translation merging)
  - phase-4-documentation.md (Docs + LLM integration)

### Key Decisions
- Configuration file will support both YAML and JSON formats
- Config path precedence: `./poflow.yml` ‚Üí `~/.config/poflow/config.yml`
- Using Cobra for CLI framework and Viper for config management
- Primary usage: `poflow translate --language sv translations.txt`
- Config resolves paths: `{gettext_path}/{lang}/LC_MESSAGES/default.po`

### Next Steps
- [ ] Initialize Go module
- [ ] Set up basic Cobra CLI structure
- [ ] Implement config file loading with Viper
- [ ] Create initial project structure (cmd/, internal/)

### Notes
- Original plan was stateless (stdin/stdout only)
- Updated to be config-driven for easier workflow
- Config allows automatic .po file path resolution by language code
- Maintains flexibility with direct file path option as fallback

---

## Session 2: Phase 1 Implementation - Core Parsing + listempty

### Goals
- Implement streaming .po file parser
- Create listempty command
- Add JSON output support
- Write comprehensive tests

### Completed
- ‚úÖ Created/verified MsgEntry struct in internal/model/entry.go
- ‚úÖ Implemented streaming parser in internal/parser/po.go
  - Handles multi-line strings
  - Handles escaped quotes (\\n, \\t, \\", \\\\)
  - Parses comments and references
  - Streams entries one by one without loading entire file
- ‚úÖ Implemented listempty command in cmd/listempty.go
  - Supports file input and stdin
  - Added --limit flag
  - Added --json output via global flag
- ‚úÖ Created comprehensive test suite (8 tests, all passing)
  - Simple pairs
  - Empty translations
  - Multi-line strings
  - Comments and references
  - Escaped quotes
  - Multiple entries
  - Newline escapes
  - ParseAll convenience function
- ‚úÖ Created test.po file for manual testing
- ‚úÖ Updated phase-1-parsing.md status to COMPLETED

### Key Decisions

**Parser Architecture:**
- Used streaming approach with bufio.Scanner to avoid loading entire file into memory
- Iterator pattern: Next() returns one entry at a time
- State machine tracks whether currently reading msgid or msgstr
- Accumulates continuation lines (quoted strings on their own lines)

**Bug Fix:**
- Initial implementation forgot to join msgidLines into entry.MsgID
- Fixed by setting entry.MsgID when transitioning to msgstr
- Also fixed end-of-file handling to check msgidLines instead of entry.MsgID

**Command Design:**
- listempty supports both file argument and stdin
- --json flag inherited from global flags (defined in root.go)
- --limit flag allows limiting output

### Testing Results

All tests pass:
```
TestParser_SimplePair         ‚úì
TestParser_EmptyTranslation   ‚úì
TestParser_MultilineString    ‚úì
TestParser_WithComments       ‚úì
TestParser_EscapedQuotes      ‚úì
TestParser_MultipleEntries    ‚úì
TestParser_NewlineEscapes     ‚úì
TestParseAll                  ‚úì
```

Manual testing verified:
- `./poflow listempty test.po` - text output works
- `./poflow listempty --json test.po` - JSON output works
- `./poflow listempty --limit 1 test.po` - limit flag works
- `cat test.po | ./poflow listempty --json` - stdin works

### Next Steps

Phase 1 is complete! Ready to move on to Phase 2: Searching

Phase 2 will implement:
- `search` command (search msgid)
- `searchvalue` command (search msgstr)
- Regex and substring matching
- JSON output

### Notes

The parser handles all the key requirements:
- Multi-line strings (empty msgid followed by continuation lines)
- Escape sequences (\\n, \\t, \\", \\\\)
- Comments (# prefix)
- Reference comments (#: prefix)
- Blank line separation between entries
- Files without trailing blank lines

The streaming approach means poflow can handle large .po files efficiently without memory issues.

---

## Session 3: Phase 2 Implementation - Search Commands

### Goals
- Implement search command (search msgid)
- Implement searchvalue command (search msgstr)
- Add regex and plain text matching support
- Write comprehensive tests

### Completed
- ‚úÖ Created cmd/search.go with full implementation
  - Plain substring matching (case-insensitive, default)
  - Regex matching with --re flag
  - --limit flag for limiting results
  - JSON output via global --json flag
  - Supports both file and stdin input
- ‚úÖ Created cmd/searchvalue.go with full implementation
  - Same features as search but searches msgstr instead of msgid
  - Separate flags to avoid conflicts
- ‚úÖ Fixed initial build errors
  - Used NewParser() instead of New()
  - Fixed Next() return value handling (returns pointer, not bool)
  - Retrieved jsonOutput from cmd.Flags().GetBool("json")
  - Dereferenced entry pointer when passing to output functions
- ‚úÖ Manual testing verified all functionality:
  - Plain search: `./poflow search "Sign" test.po` ‚úì
  - JSON output: `./poflow search --json "Sign" test.po` ‚úì
  - Regex search: `./poflow search --re "^Sign" test.po` ‚úì
  - Search by value: `./poflow searchvalue "Logga" test.po` ‚úì
  - Limit flag: `./poflow search --limit 1 "Sign" test.po` ‚úì
  - Stdin input: `cat test.po | ./poflow searchvalue --json "ut"` ‚úì
- ‚úÖ Created comprehensive test suite in internal/parser/search_test.go
  - TestSearchScenarios: substring match, exact match, case insensitive, no match
  - TestSearchValueScenarios: search translations, empty translations, no match
  - TestSearchLimit: verify limit functionality
  - All 11 tests pass ‚úì
- ‚úÖ Updated plans/phase-2-searching.md to COMPLETED

### Key Decisions

**Command Design:**
- Both commands use same flag structure but separate variables to avoid conflicts
- Default behavior is case-insensitive substring matching (most common use case)
- --re flag enables regex for power users
- --limit flag applies to output (stops after N matches)
- Both commands support file argument OR stdin input

**Output Format:**
- Text mode: comments, references, msgid, msgstr (human-readable)
- JSON mode: one JSON object per line (LLM/script-friendly)
- Consistent with listempty output format

**Testing Strategy:**
- Tests focus on realistic search scenarios
- Test both msgid and msgstr searching
- Test case-insensitive matching
- Test limiting results
- All tests use streaming parser (integration-style tests)

### Testing Results

Manual testing results:
```bash
# Plain search
./poflow search "Sign" test.po
# Found: "Sign In" and "Sign Out" ‚úì

# JSON output
./poflow search --json "Sign" test.po
# {"msgid":"Sign In",...} ‚úì

# Regex search
./poflow search --re "^Sign" test.po
# Both entries match ‚úì

# Search by translation value
./poflow searchvalue "Logga" test.po
# Found: "Sign Out" -> "Logga ut" ‚úì

# Limit results
./poflow search --limit 1 "Sign" test.po
# Only "Sign In" returned ‚úì

# Stdin input
cat test.po | ./poflow searchvalue --json "ut"
# {"msgid":"Sign Out",...} ‚úì
```

All parser tests pass:
```
go test ./...
ok  github.com/xnilsson/poflow/internal/parser (11 tests)
```

### Next Steps

Phase 2 is complete! Ready to move on to Phase 3: Translation

Phase 3 will implement:
- `translate` command to merge translations
- Config-based path resolution
- Support for `--language` flag
- Merge translations from text files into .po files

### Notes

**Implementation Notes:**
- Used same parser as listempty (consistent API)
- Separate flag variables for each command (searchFlags, searchvalueFlags)
- Helper functions outputJSON/outputText and outputJSONValue/outputTextValue
- Could potentially be refactored to share output code, but keeping separate is clearer

**Search Behavior:**
- Plain search converts both pattern and entry to lowercase for case-insensitive matching
- Regex search uses Go's regexp package with full regex syntax support
- Empty string matches everything (useful for "show all translated entries")

**Edge Cases Handled:**
- Empty msgid (file header) is included in search results
- Empty msgstr is valid search target
- No matches returns cleanly with no output
- Invalid regex pattern returns helpful error message

Phase 2 complete! All search functionality working perfectly.

---

## Session 4: Phase 3 Implementation - Translation

### Goals
- Implement translation parser for input format (msgid = msgstr)
- Create translate command with merge functionality
- Add --language flag for config-based path resolution
- Write comprehensive tests

### Completed
- ‚úÖ Created internal/parser/translate.go
  - ParseTranslations() function to parse "msgid = msgstr" format
  - Returns map[string]string for fast lookups
  - Handles comments (# prefix) and empty lines
  - Validates format and reports line numbers in errors
  - Allows empty msgstr (clearing translations)
  - Allows equals signs in msgstr values
- ‚úÖ Created cmd/translate.go with full implementation
  - Supports both file input and stdin for translations
  - Supports both --language flag (config-based) and direct file path
  - --force flag to ignore missing msgid warnings
  - Preserves comments and references from original .po file
  - Shows warnings for msgids not found in .po file
  - Updates msgstr values while keeping msgid and metadata
  - Supports --json output via global flag
- ‚úÖ Created comprehensive test suite (8 tests, all passing)
  - TestParseTranslations_Simple
  - TestParseTranslations_WithComments
  - TestParseTranslations_WithEmptyLines
  - TestParseTranslations_WithWhitespace
  - TestParseTranslations_InvalidFormat (2 scenarios)
  - TestParseTranslations_MsgstrWithEquals
  - TestParseTranslations_EmptyMsgstr
- ‚úÖ Manual testing verified all functionality:
  - `./poflow translate test.po translations.txt` ‚úì
  - `echo "Sign In = Inloggning" | ./poflow translate test.po` ‚úì
  - `./poflow translate --json test.po translations.txt` ‚úì
  - `echo "NonExistent = Test" | ./poflow translate test.po` (warning) ‚úì
  - `echo "NonExistent = Test" | ./poflow translate --force test.po` ‚úì
- ‚úÖ Updated plans/phase-3-translation.md to COMPLETED

### Key Decisions

**Translation Parser:**
- Simple format: `msgid = msgstr` (one per line)
- Uses `strings.SplitN(line, "=", 2)` to allow equals signs in msgstr
- Comments start with # (like .po files)
- Empty lines are ignored
- Whitespace around msgid and msgstr is trimmed
- Empty msgid is an error, but empty msgstr is valid

**Translate Command:**
- Two modes:
  1. Config-based: `--language sv` resolves to `{gettext_path}/sv/LC_MESSAGES/default.po`
  2. Direct path: `translate file.po` uses explicit path
- Translation input from:
  1. File argument: `translate file.po translations.txt`
  2. Stdin: `echo "..." | translate file.po`
- Output goes to stdout (original file unchanged)
- User can redirect to new file or pipe to another command

**Error Handling:**
- Warns about msgids not found in .po file
- By default, exits with error if any msgid not found
- --force flag allows continuing despite warnings
- Shows count of updated entries
- Parser errors include line numbers

**Output Format:**
- Text mode: reconstructs .po format with updated msgstr
- JSON mode: outputs one entry per line (like other commands)
- Preserves comments and references from original .po file
- Handles multi-line msgid/msgstr correctly

### Testing Results

All parser tests pass:
```
go test ./internal/parser/
ok  github.com/xnilsson/poflow/internal/parser (8 tests)
```

Manual testing results:
```bash
# Basic file-based translation
./poflow translate test.po translations.txt
# Updated 3 entries: Sign In, Sign Out, Welcome ‚úì

# Stdin translation input
echo "Sign In = Inloggning" | ./poflow translate test.po
# Updated 1 entry ‚úì

# JSON output
./poflow translate --json test.po translations.txt
# JSON objects per line ‚úì

# Missing msgid warning
echo "NonExistent = Test" | ./poflow translate test.po
# Warning: 1 msgid(s) not found
# Error: some translations not applied ‚úì

# Force flag
echo "NonExistent = Test" | ./poflow translate --force test.po
# Warning but no error, continues ‚úì
```

### Next Steps

Phase 3 is complete! Ready to move on to Phase 4: Documentation + LLM Integration

Phase 4 will implement:
- Comprehensive README with usage examples
- LLM usage guide
- --json-help flag for structured help output
- Example workflows and best practices

### Notes

**Implementation Highlights:**
- Translation parser is simple and robust
- Translate command integrates well with existing config system
- Preserves all .po file metadata (comments, references)
- Output goes to stdout for flexibility (redirect, pipe, etc.)
- Error handling helps users fix issues quickly

**Design Decisions:**
- Used map[string]string for translations (fast O(1) lookups)
- Mark translations as "used" by deleting from map after matching
- Remaining translations in map = not found in .po file
- outputEntryText() and outputEntryJSON() handle multi-line strings
- Consistent with listempty/search output format

**Edge Cases Handled:**
- Empty msgstr (valid - clears translation)
- Equals signs in msgstr (valid - "x = y + 1")
- Missing msgids (warns and errors by default)
- Comments in translation input (ignored)
- Empty lines in translation input (ignored)
- Whitespace around msgid/msgstr (trimmed)

**Config Integration:**
- Reuses existing config.Load() and ResolvePOPath()
- --language flag integrates seamlessly
- Falls back to direct file path if --language not specified
- Clear error messages if config missing or invalid

Phase 3 complete! All translation functionality working perfectly.

---

## Session 5: Phase 4 Implementation - Documentation + LLM Integration

### Goals
- Complete Phase 4: Documentation
- Write comprehensive README.md
- Create LLM integration guide
- Finalize project documentation

### Completed
- ‚úÖ Created comprehensive README.md with all required sections
- ‚úÖ Added installation instructions (binary download, build from source, go install)
- ‚úÖ Documented all commands with examples (listempty, search, searchvalue, translate)
- ‚úÖ Created detailed LLM integration guide with workflow examples
- ‚úÖ Added configuration documentation with examples for different project types
- ‚úÖ Included real-world usage examples and workflows
- ‚úÖ Added troubleshooting section covering common issues
- ‚úÖ Documented .po file format support and limitations
- ‚úÖ Added development and contributing guidelines
- ‚úÖ Updated phase-4-documentation.md to COMPLETED

### README Structure

The README includes:

1. **Introduction**: What is poflow, features overview
2. **Installation**: Three methods (binary, source, go install)
3. **Quick Start**: Common usage examples
4. **Configuration**: Config file setup, locations, examples
5. **Commands**: Detailed docs for all 4 commands
   - listempty
   - search
   - searchvalue
   - translate
6. **Global Flags**: Shared options across commands
7. **LLM Integration**: Complete workflow guide
   - Recommended workflow (4 steps)
   - Example prompts
   - Why JSON output
   - Programmatic usage examples
8. **Real-World Examples**: Practical workflows
   - Translate next 10 strings
   - Find login-related strings
   - Check translation coverage
   - Batch process multiple languages
9. **Troubleshooting**: Common problems and solutions (6 issues)
10. **File Format**: .po file structure, supported features
11. **Development**: Build, test, code structure, contributing

### Key Documentation Features

**LLM-Friendly Design:**
- Clear workflow: list ‚Üí translate (LLM) ‚Üí apply
- Example prompts for LLMs
- JSON output benefits explained
- Programmatic usage with jq, pipes

**Practical Examples:**
- All commands have multiple examples
- Real workflows (batch translation, coverage checking)
- Integration with LLM tools

**Configuration Made Easy:**
- Examples for Phoenix/Elixir, Rails, custom setups
- Config file resolution order explained
- Path resolution with --language flag

**Troubleshooting:**
- 6 common issues with solutions:
  1. Config file not found
  2. File not found with --language flag
  3. Regex pattern not matching
  4. Translation not applied
  5. Multi-line strings not parsing
  6. Performance issues with large files

### Next Steps
- Update phase-4-documentation.md to mark COMPLETED
- Move phase-4 plan to archive/
- Project is now feature-complete for v0.1!

### Key Decisions

**README Structure:**
- Focused on practical usage over API docs
- LLM integration as first-class feature
- Real-world examples prominent
- Troubleshooting section to reduce support burden

**Documentation Philosophy:**
- Examples over explanations
- Show workflows, not just commands
- Educational help text
- JSON output benefits clearly explained

**Skipped --json-help flag:**
- Help text is already deterministic
- JSON output for data is sufficient
- Adding machine-readable help adds complexity without clear benefit
- Can be added in v0.2 if needed

### Notes

Phase 4 is complete! The README is comprehensive and covers:
- All features implemented in phases 1-3
- Complete LLM integration guide
- Practical examples and workflows
- Troubleshooting for common issues

The project is now ready for:
- v0.1 release
- GitHub publish
- User testing and feedback

All core functionality is working:
- Fast streaming parser ‚úÖ
- Search by msgid and msgstr ‚úÖ
- List untranslated entries ‚úÖ
- Merge translations ‚úÖ
- JSON output ‚úÖ
- Config file support ‚úÖ
- LLM-friendly design ‚úÖ

**Project Status: v0.1 MVP COMPLETE** üéâ

---

## Session 6: Bug Fix - Missing --language Flag in listempty

### Problem
User reported that `listempty` command was advertising `--language` flag in its help examples but didn't actually implement it. This is exactly the kind of regression that should be caught by tests.

```bash
# Help text showed:
poflow listempty --language sv --json

# But command failed with:
Error: unknown flag: --language
```

### Root Cause
- `cmd/listempty.go` showed `--language` usage in help examples (line 26)
- But `init()` function never added the flag (only had `--limit`)
- No command-level integration tests to catch this

### Completed
- ‚úÖ Added `listEmptyLanguage` string variable to hold flag value
- ‚úÖ Added `--language` flag definition in `init()` function
- ‚úÖ Updated `runListEmpty()` to handle `--language` flag
- ‚úÖ Integrated with config.Load() and ResolvePOPath() for path resolution
- ‚è≥ TODO: Create cmd-level integration tests
- ‚è≥ TODO: Verify all commands work correctly with manual testing

### Implementation Details

**Changes to cmd/listempty.go:**
1. Added `listEmptyLanguage string` variable alongside `listEmptyLimit`
2. Added flag: `listemptyCmd.Flags().StringVar(&listEmptyLanguage, "language", "", "language code (uses config to resolve path)")`
3. Added `internal/config` import
4. Updated `runListEmpty()` to check `--language` flag first:
   - If `--language` set: Load config ‚Üí Resolve path ‚Üí Open file
   - Else if file arg: Open file directly
   - Else: Use stdin

**Priority Order:**
1. `--language` flag (highest priority)
2. File argument
3. Stdin (default)

### Testing Plan

Need to create integration tests for all commands:
- `cmd/listempty_test.go`
- `cmd/search_test.go`
- `cmd/searchvalue_test.go`
- `cmd/translate_test.go`

Tests should verify:
- All advertised flags are actually implemented
- Flag combinations work correctly
- Help examples are accurate
- Error messages are helpful

### Next Steps
- Create comprehensive cmd-level integration tests
- Verify all commands (`search`, `searchvalue`, `translate`) handle `--language` correctly
- Manual test all commands to ensure no other missing features
- Consider adding CI/CD to catch these issues automatically

### Notes

This is a good lesson about test coverage:
- Internal parser tests exist and pass
- But cmd-level tests were missing
- Help text and implementation got out of sync
- User found the bug by trying to use the advertised feature

The `--language` flag pattern should be consistent across all commands that support it. Need to audit `search` and `searchvalue` to ensure they also support it (if advertised).

---

## Session 7: Language Flag Consistency + Integration Test Suite

### Problem
User reported that `search` command failed with `--language` flag:
```bash
./poflow search "Ask a question" --language sv
# Error: unknown flag: --language
```

Both `search` and `searchvalue` commands were missing the `--language` flag, creating inconsistency across the CLI.

### Goals
- Add `--language` flag to `search` and `searchvalue` commands
- Create comprehensive integration test suite
- Test all commands from TUTORIAL.md
- Prevent future regressions with automated tests

### Completed
- ‚úÖ Added `--language` flag to `search` command (cmd/search.go:42)
- ‚úÖ Added `--language` flag to `searchvalue` command (cmd/searchvalue.go:42)
- ‚úÖ Fixed variable shadowing issues (used distinct variable names: cfgErr, pathErr, openErr)
- ‚úÖ Created test fixtures directory structure (testdata/)
- ‚úÖ Created test configuration file (testdata/poflow.yml)
- ‚úÖ Created sample .po file with test data (testdata/gettext/sv/LC_MESSAGES/default.po)
- ‚úÖ Created comprehensive integration test suite (test_integration.sh)
- ‚úÖ All 25 integration tests passing
- ‚úÖ Updated README.md with integration test documentation (line 537-546)

### Implementation Details

**Language Flag Implementation:**
Both commands now follow the same pattern as `listempty`:

1. Added `language string` field to flags struct
2. Added flag definition in `init()`: `--language` with usage text
3. Updated run function to check `--language` first:
   - If set: Load config ‚Üí Resolve path ‚Üí Open file
   - Else if file arg: Open directly
   - Else: Use stdin
4. Used distinct variable names to avoid shadowing: `cfgErr`, `pathErr`, `openErr`

**Priority Order (consistent across all commands):**
1. `--language` flag (highest)
2. File argument
3. Stdin (default)

**Variable Shadowing Fix:**
Original code had `err` declared twice, causing compile errors:
```go
var err error              // Declared once
cfg, err := config.Load()  // Redeclared (shadowing)
```

Fixed by using distinct names:
```go
cfg, cfgErr := config.Load()
path, pathErr := cfg.ResolvePOPath(...)
var openErr error
reader, openErr = os.Open(path)
```

### Integration Test Suite

**Test Data Structure:**
```
testdata/
‚îú‚îÄ‚îÄ poflow.yml                              # Config: gettext_path: "testdata/gettext"
‚îî‚îÄ‚îÄ gettext/sv/LC_MESSAGES/default.po       # Sample .po file (7 entries)
```

**Sample Test Data:**
- 7 translation entries (4 empty, 3 translated)
- English source strings: "Sign In", "Sign Out", "Profile", "Welcome", "Ask a question", "Click here", "Submit"
- Swedish translations where present: "Logga ut", "V√§lkommen", "St√§ll en fr√•ga"
- Realistic comment structure with file references

**Test Coverage (25 tests):**

1. **Version command** (1 test)
2. **listempty command** (6 tests)
   - With file path
   - With --language flag
   - With --json flag
   - With --limit flag
   - From stdin
   - Output validation
3. **search command** (7 tests)
   - Plain text search
   - With --language flag
   - With --re (regex) flag
   - With --json flag
   - With --limit flag
   - From stdin
   - Output validation
4. **searchvalue command** (5 tests)
   - Plain text search
   - With --language flag
   - With --re (regex) flag
   - With --json flag
   - Output validation
5. **Help commands** (4 tests)
   - poflow --help
   - search --help
   - searchvalue --help
   - listempty --help
6. **JSON format validation** (2 tests)

**Test Script Features:**
- Color-coded output (green for pass, red for fail)
- Clear test descriptions
- Exit code validation
- Output pattern matching
- Builds poflow before running tests
- Summary report at the end
- Exits with proper status code

### Test Results
```
Total tests: 25
Passed: 25 ‚úì
Failed: 0
```

All tests passing! The integration test suite successfully validates:
- All commands work with --language flag
- JSON output is properly formatted
- Regex patterns work correctly
- Limit flags work as expected
- Stdin input works for all commands
- Help text is accessible

### Key Decisions

**Test Design:**
- Self-contained test fixtures (no external dependencies)
- Realistic .po file structure
- Tests based on TUTORIAL.md examples
- Both exit code and output validation
- Fast execution (~1 second)

**Integration vs Unit Tests:**
- Unit tests: Internal parser logic (already exist)
- Integration tests: End-to-end command validation (new)
- Integration tests catch flag inconsistencies
- Integration tests validate user-facing behavior

**Documentation:**
- Updated README.md with test instructions
- Listed what integration tests cover
- Kept it concise (4 bullet points)

### Next Steps

For future improvements:
- Consider adding integration tests to CI/CD
- Add edge case tests (empty files, malformed entries)
- Test error conditions (missing config, invalid paths)
- Add performance benchmarks for large .po files

### Notes

**Consistency Achieved:**
All commands now support the same flags where applicable:
- `listempty`: --language, --limit, --json
- `search`: --language, --limit, --json, --re
- `searchvalue`: --language, --limit, --json, --re
- `translate`: --language (already existed)

**Test Suite Value:**
The integration test suite would have caught the original `--language` flag bugs immediately. This investment in testing infrastructure will prevent future regressions and give confidence when refactoring.

**Variable Naming Pattern:**
For nested scopes where config loading might shadow outer `err`:
- `cfgErr` for config.Load() errors
- `pathErr` for path resolution errors
- `openErr` for file open errors
- `parseErr` for parsing errors

This pattern is clearer than reusing `err` and avoids Go's variable shadowing issues.

### Verification

Tested the original failing command:
```bash
./poflow --config testdata/poflow.yml search "Ask a question" --language sv
# Output:
# msgid "Ask a question"
# msgstr "St√§ll en fr√•ga"
# ‚úì Works!
```

All commands now support `--language` flag consistently. Integration tests provide confidence for future changes.

**Status: Issue resolved, test suite added** ‚úÖ
