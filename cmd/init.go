package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize a poflow config file in the current directory",
	Long: `Initialize a poflow config file in the current directory.

This command creates a poflow.yml configuration file with sensible defaults
based on your project structure.

Examples:
  poflow init
  poflow init --path priv/gettext
  poflow init --path config/locales`,
	RunE: runInit,
}

var (
	initPath string
)

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.Flags().StringVarP(&initPath, "path", "p", "", "custom gettext path")
}

func runInit(cmd *cobra.Command, args []string) error {
	configPath := "poflow.yml"

	// Check if config already exists
	if _, err := os.Stat(configPath); err == nil {
		return fmt.Errorf("config file already exists: %s (use --force to overwrite)", configPath)
	}

	// Detect project type or use provided path
	gettextPath := initPath
	if gettextPath == "" {
		gettextPath = detectGettextPath()
	}

	// Create config content
	configContent := fmt.Sprintf(`# poflow configuration file
# Generated by poflow init

# Base path for gettext files
# The tool will resolve .po files as: {gettext_path}/{lang}/LC_MESSAGES/default.po
gettext_path: "%s"

# Examples:
# For Phoenix/Elixir projects: "priv/gettext"
# For Rails projects: "config/locales"
# For custom setup: "translations" or any other path
`, gettextPath)

	// Write config file
	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	fmt.Fprintf(os.Stderr, "✓ Created %s\n", configPath)
	fmt.Fprintf(os.Stderr, "✓ Configured gettext_path: %s\n", gettextPath)
	fmt.Fprintf(os.Stderr, "\nNext steps:\n")
	fmt.Fprintf(os.Stderr, "  1. Edit %s if needed\n", configPath)
	fmt.Fprintf(os.Stderr, "  2. Run: poflow listempty --language <lang>\n")
	fmt.Fprintf(os.Stderr, "  3. See: poflow --help for all commands\n")

	return nil
}

// detectGettextPath attempts to detect the gettext path based on project structure
func detectGettextPath() string {
	// Check for common project structures
	checks := []struct {
		file string
		path string
		desc string
	}{
		{"mix.exs", "priv/gettext", "Phoenix/Elixir"},
		{"config/application.rb", "config/locales", "Rails"},
		{"package.json", "translations", "Node.js"},
	}

	for _, check := range checks {
		if _, err := os.Stat(check.file); err == nil {
			// Found project file, verify gettext path exists
			if stat, err := os.Stat(check.path); err == nil && stat.IsDir() {
				fmt.Fprintf(os.Stderr, "Detected %s project\n", check.desc)
				return check.path
			}
		}
	}

	// Default to looking for any existing gettext-like directories
	candidates := []string{"priv/gettext", "translations", "locale", "locales", "config/locales"}
	for _, candidate := range candidates {
		if stat, err := os.Stat(candidate); err == nil && stat.IsDir() {
			// Check if it looks like a gettext directory (has subdirs)
			if hasGettextStructure(candidate) {
				return candidate
			}
		}
	}

	// Default fallback
	return "priv/gettext"
}

// hasGettextStructure checks if a directory contains gettext-like structure
func hasGettextStructure(path string) bool {
	entries, err := os.ReadDir(path)
	if err != nil {
		return false
	}

	// Look for language code directories (2-letter codes)
	for _, entry := range entries {
		if entry.IsDir() && len(entry.Name()) == 2 {
			// Check for LC_MESSAGES subdirectory
			lcMessages := filepath.Join(path, entry.Name(), "LC_MESSAGES")
			if stat, err := os.Stat(lcMessages); err == nil && stat.IsDir() {
				return true
			}
		}
	}

	return false
}
